{{mergefrom|散列}}
{{NoteTA
|G1 = IT
|1 = zh-cn:健壮; zh-tw:強韌;
}}
'''[[散列|散列]]函数'''（{{lang-en|Hash function}}）又称-{zh-cn:'''散列算法'''、'''哈希函数'''; zh-tw:'''雜湊演算法'''}-，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该[[函数|函数]]将数据打乱混合，重新创建一个叫做'''散列值'''（{{lang|en|hash values}}，{{lang|en|hash codes}}，{{lang|en|hash sums}}，或{{lang|en|hashes}}）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现[[散列冲突|散列冲突]]。在[[散列表|散列表]]和[[数据处理|数据处理]]中，不抑制冲突来区别数据，会使得[[数据库记录|数据库记录]]更难找到。

[[File:Hash_function.svg|thumb]]

== 散列函数的性质 ==
所有散列函数都有如下一个基本特性：如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有[[确定性|确定性]]的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为「[[雜湊碰撞|雜湊碰撞]]（collision）」，这通常是两个不同长度的输入值，刻意计算出相同的输出值。输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。

典型的散列函数都有非常大的[[定义域|定义域]]，比如[[SHA-2|SHA-2]]最高接受(2<sup>64</sup>-1)/8长度的[[字节|字节]][[字符串|字符串]]。同時散列函數一定有着有限的[[值域|值域]]，比如固定长度的[[位元|比特]]串。在某些情况下，散列函数可以设计成具有相同大小的定义域和值域间的[[單射|單射]]。在密码学中，散列函數必須具有不可逆性。

== 散列函数的应用 ==
由于散列函数的应用的多样性，它们经常是专为某一应用而设计的。例如，[[加密散列函数|加密散列函数]]假设存在一个要找到具有相同散列值的原始输入的敌人。一个设计优秀的加密散列函数是一个「单向」操作：对于给定的散列值，没有实用的方法可以计算出一个原始输入，也就是说很难伪造。为加密散列为目的设计的函数，如[[SHA-2|SHA-2]]，被广泛的用作检验散列函数。這樣軟件下載的時候，就會對照驗證代碼之後才下載正確的文件部分。此代碼有可能因為環境因素的變化，如機器配置或者IP地址的改變而有變動。以保證源文件的安全性。

错误监测和修复函数主要用于辨别数据被随机的过程所扰乱的事例。当散列函数被用于校验和的时候，可以用相对较短(但不能短於某個安全參數, 通常不能短於160位)的散列值来验证任意长度的数据是否被更改过。

=== 保護資料 ===
{{main|密碼雜湊函数}}

雜湊值可用於唯一地識別機密資訊。這需要雜湊函式是抗碰撞(collision-resistant)的，意味著很難找到產生相同雜湊值的資料。雜湊函式分類為密碼雜湊函式和可證明的安全雜湊函式。第二類中的函式最安全，但對於大多數實際目的而言也太慢。透過生成非常大的雜湊值來部分地實現抗碰撞。例如，SHA-2是最廣泛使用的密碼雜湊函式之一，它生成256位元值。

=== 确保传递真实的信息 ===
消息或数据的接受者确认消息是否被篡改的性质叫数据的真实性，也称为完整性。发信人通过将原消息和散列值一起发送，可以保证真实性。

=== 散列表 ===
{{main|散列表}}

散列表是散列函数的一个主要应用，使用散列表能够快速的按照''关键字''查找数据记录。（注意：关键字不是像在[[加密|加密]]中所使用的那样是秘密的，但它们都是用来“解锁”或者访问数据的。）例如，在英语字典中的关键字是英文单词，和它们相关的记录包含这些单词的定义。在这种情况下，散列函数必须把按照字母顺序排列的字符串映射到为散列表的内部[[数组|数组]]所建立的索引上。

散列表散列函数的几乎不可能/不切实际的理想是把每个关键字映射到唯一的索引上（参考[[完美散列|完美散列]]），因为这样能够保证直接访问表中的每一个数据。

一个好的散列函数（包括大多数[[加密散列函数|加密散列函数]]）具有均匀的真正随机输出，因而平均只需要一两次探测（依赖于[[装填因子|装填因子]]）就能找到目标。同样重要的是，随机散列函数不太會出现非常高的[[冲突率|冲突率]]。但是，少量的可以估计的冲突在实际狀況下是不可避免的（参考[[生日悖论|生日悖论]]或[[鴿洞原理|鴿洞原理]]）。

在很多情况下，[[Heuristic_(computer_science)|heuristic]]散列函数所产生的冲突比随机散列函数少的多。Heuristic函数利用了相似关键字的[[相似性|相似性]]。例如，可以设计一个heuristic函数使得像<tt>FILE0000.CHK</tt>, <tt>FILE0001.CHK</tt>, <tt>FILE0002.CHK</tt>，等等这样的文件名映射到表的连续指针上，也就是说这样的序列不会发生冲突。相比之下，对于一组好的关键字性能出色的随机散列函数，对于一组坏的关键字经常性能很差，这种坏的关键字会自然产生而不仅仅在[[攻击|攻击]]中才出现。性能不佳的散列函数表意味着查找操作会退化为费时的[[线性搜索|线性搜索]]。

=== 错误校正 ===
{{main|错误校正与检测}}

使用一个散列函数可以很直观的检测出数据在传输时发生的错误。在数据的发送方，对将要发送的数据应用散列函数，并将计算的结果同原始数据一同发送。在数据的接收方，同样的散列函数被再一次应用到接收到的数据上，如果两次散列函数计算出来的结果不一致，那么就说明数据在传输的过程中某些地方有错误了。这就叫做[[冗余校验|冗余校验]]。

校正错误时，至少会对可能出现的扰动大致假定一个分布模式。对于一个信息串的微扰可以被分为两类，大的（不可能的）错误和小的（可能的）错误。我们对于第二类错误重新定义如下，假如给定H（x）和x+s，那么只要s足够小，我们就能有效的计算出x。那样的散列函数被称作错误校正编码。这些错误校正编码有两个重要的分类：[[循环冗余校验|循环冗余校验]]和[[里德-所罗门码|里德-所罗门码]]。

=== 语音识别 ===
对于像从一个已知列表中匹配一个MP3文件这样的应用，一种可能的方案是使用传统的散列函数——例如[[MD5|MD5]]，但是这种方案会对时间平移、CD读取错误、不同的音频压缩算法或者音量调整的实现机制等情况非常敏感。使用一些类似于MD5的方法有利于迅速找到那些严格相同（从音频文件的二进制数据来看）的音频文件，但是要找到全部相同（从音频文件的内容来看）的音频文件就需要使用其他更高级的算法了。

那些并不紧随IT工业潮流的人往往能反其道而行之，对于那些微小差异足够健壮的散列函数确实存在。现存的绝大多数散列算法都是不够健壮的，但是有少数散列算法能够达到辨别从嘈杂房间里的扬声器里播放出来的音乐的健壮性。有一个实际的例子是[[Shazam_Entertainment|Shazam]][http://www.shazam.com/] 服务。用户可以用手机打开其app，并将话筒靠近用于播放音乐的扬声器。该项服务会分析正在播放的音乐，并将它于存储在数据库中的已知的散列值进行比较。用户就能够收到被识别的音乐的曲名。

=== Rabin-Karp字符串搜索算法 ===
[[Rabin-Karp字符串搜索算法|Rabin-Karp字符串搜索算法]]是一个相对快速的[[字符串搜索算法|字符串搜索算法]]，它所需要的平均搜索时间是[[大O符号|O(n)]].这个算法是建立在使用散列来比较字符串的基础上的。

== 参阅 ==
* [[交叉点表|交叉点表]]

== 参考资料 ==
* [https://web.archive.org/web/20050530071005/http://www.extra.research.philips.com/natlab/download/audiofp/cbmi01audiohashv1.0.pdf Robust Audio Hashing for Content Identification]

== 外部链接 ==
* [http://www.sigma.me/2011/09/13/hash-and-bloom-filter.html Hash和Bloom Filter介绍]
* [http://www.partow.net/programming/hashfunctions/index.html General purpose hash function algorithms C/C++/Pascal/Java/Ruby]
* [http://burtleburtle.net/bob/hash/evahash.html Hash Functions for Hash Table Lookup] by Bob Jenkins
* [http://www.azillionmonkeys.com/qed/hash.html 散列函数]by Paul Hsieh
* [https://web.archive.org/web/20061206022506/http://www.rsasecurity.com/rsalabs/node.asp?id=2176 什么是散列函数?] from RSA Laboratories
* [http://arquivo.pt/wayback/20100530092446/http%3A//home1.paulschou.net/tools/xlate/ Online Char（ASCII）,HEX, Binary, Base64, etc... Encoder/Decoder with MD2, MD4, MD5, SHA1+2, etc. hashing algorithms]
* [http://3amsystems.com/monetics/crypto.php Crypto-Toolbox] - Online cryptography, hashing and PIN block sanity checking for EftPos developers.
* [https://passwordsgenerator.pro/sha256 Hash值在线计算]

[[Category:搜尋演算法|Category:搜尋演算法]]
[[Category:错误检测与校正|Category:错误检测与校正]]
[[Category:散列函数|]]