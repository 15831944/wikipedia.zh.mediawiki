{{noteTA
|G1 = IT
|1 = zh-cn:程序; zh-tw:程式;
}}
{{Expand English}}
{{Program execution}}

'''編譯器'''（{{lang|en|compiler}}），是一種[[電腦程式|電腦程式]]，它會將用某種程式語言寫成的[[原始碼|原始碼]]（原始語言），轉換成另一種程式語言（目標語言）。

它主要的目的是將便于人编写、阅读、维护的高级计算机语言所寫作的[[原始碼|原始碼]]程式，翻译为计算机能解读、运行的低阶机器语言的程序，也就是[[執行檔|執行檔]]。编译器将原始程序（source program）作为输入，翻译产生使用目标语言（target language）的等价程序。[[源代码|源代码]]一般为高阶语言（High-level language），如Pascal、C、C++、C# 、Java等，而目标语言则是汇编语言或目标机器的目标代码（Object code），有时也称作[[机器代码|机器代码]]（Machine code）。

一个现代编译器的主要工作流程如下：

[[源代码|源代码]]（source code）→ [[预处理器|预处理器]]（preprocessor）→ [[编译器|编译器]]（compiler）→ [[汇编程序|汇编程序]]（assembler）→ [[目标代码|目标代码]]（object code）→ [[链接器|链接器]]（Linker）→ [[執行檔|執行檔]]（executables），最後打包好的檔案就可以給電腦去判讀執行了。

== 历史 ==
早期的计算机软件都是用汇编语言直接编写的，这种状况持续了数年。当人们发现为不同类型的[[中央处理器|中央处理器]]（CPU）编写可重用软件的开销要明显高于编写编译器时，人们发明了高级编程语言。由于早期的计算机的[[内存|内存]]很少，当大家实现编译器时，遇到了许多技术难题。

大约在20世纪50年代末期，与机器无关的编程语言被首次提出。随后，人们开发了几种实验性质的编译器。第一个编译器是由美國女性電腦科學家[[葛麗絲·霍普|葛麗絲·霍普]]（Grace Murray Hopper）于1952年为[[A-0_系統|A-0 系統]]编写的。但是1957年由任職於[[IBM|IBM]]的美國電腦科學家[[约翰·巴科斯|约翰·巴科斯]]（John Warner Backus）领导的[[FORTRAN|FORTRAN]]則是第一個被實作出具備完整功能的编译器。1960年，[[COBOL|COBOL]]成为一种较早的能在多种架构下被编译的语言。

高级语言在许多领域流行起来。由于新的编程语言支持的功能越来越多，计算机的架构越来越复杂，这使得编译器也越来越复杂。

早期的编译器是用汇编语言编写的。首个能编译自己源程序的编译器是在1962年由[[麻省理工学院|麻省理工学院]]的Hart和Levin制作的。从20世纪70年代起，实现能编译自己源程序的编译器变得越来越可行，不过还是用[[Pascal_(编程语言)|Pascal]]和[[C语言|C语言]]来实现编译器更加流行。制作某种语言的第一个能编译器，要么需要用其它语言来编写，要么就像Hart和Levin制作[[Lisp|Lisp]]编译器那样，用[[解释器|解释器]]来运行编译器。

=== 教学用的编译器 ===
编译器的构造与优化是[[计算机科学|计算机]]专业的大学课程，<ref>Chakraborty, P., Saxena, P. C., Katti, C. P., Pahwa, G., Taneja, S. A new practicum in compiler construction. ''Computer Applications in Engineering Education'', In Press. http://onlinelibrary.wiley.com/doi/10.1002/cae.20566/pdf</ref>课程名称一般为「编译原理」或「編譯器」。通常在课程中包含了如何实现一种教学用程序语言的编译器。一个著名的例子是20世纪70年代，瑞士計算機科學家[[尼克劳斯·维尔特|尼克劳斯·维尔特]]（{{lang|de|Niklaus Emil Wirth}}）用于讲解编译器的构造时使用的{{link-en|PL/0|PL/0}}编译器。尽管它很简单，PL/0编译器介绍了这个领域的几个有影响的概念：

# 逐步求精的程序开发（也是 1971年 Wirth 的论文的标题）<ref>{{cite web |url=http://www.acm.org/classics/dec95/ |title=The ACM Digital Library |deadurl=yes |archiveurl=https://web.archive.org/web/20070717153035/http://www.acm.org/classics/dec95/ |archivedate=2007-07-17 }}</ref>
# 使用{{link-en|递归下降解析器|Recursive descent parser}}
# 使用[[EBNF|EBNF]]指定语言的语法。
# 代码生成器产生便携[[P-code机|P-code]]
# 在自举问题的正式描述中使用T-diagram。

== 编译器输出 ==
编译器的一种分类方式是按照生成代码所运行的[[系统平台|系统平台]]划分，这个平台称为目标平台。

有一些编译器输出的代码，将运行于与编译器所在相同类型的计算机和操作系统之上，这种编译器叫做本地编译器。输出可以运行于不同的平台之上的编译器，叫做[[交叉编译器|交叉编译器]]。由于[[嵌入式系统|嵌入式系统]]通常没有软件开发环境，因此，为这类系统开发软件时，通常需要使用交叉编译器。

编译器所输出于[[虚拟机|虚拟机]]上运行之代码，编译器和编译器输出的运行平台有可能相同，也有可能不同。因此，对于这类编译器，不去区分它是本地编译器还是交叉编译器。

== 参考文献 ==
{{Reflist}}

== 参见 ==
{{Portal box|软件|计算机程序设计|计算机科学}}
* [[链接器|链接器]]
* [[直译器|直译器]]

{{-}}
{{Computer Science}}

{{Authority control}}

[[Category:编译器软件|]]
[[Category:程序设计工具|Category:程序设计工具]]