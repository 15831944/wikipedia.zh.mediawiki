{{NoteTA
|G1 = IT
}}
{{特征检测(计算机视觉)导航框}}

'''边缘检测'''（{{lang-en|Edge detection}}）是[[图像处理|图像处理]]和[[计算机视觉|计算机视觉]]中的基本问题，'''边缘检测'''的目的是标识[[数字图像|数字图像]]中[[亮度|亮度]]变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。这些包括（i）深度上的不连续、（ii）表面方向不连续、（iii）物质属性变化和（iv）场景照明变化。
边缘检测是[[图像处理|图像处理]]和[[计算机视觉|计算机视觉]]中，尤其是[[特征检测|特征检测]]中的一个研究领域。

图像边缘检测大幅度地减少了数据量，并且剔除了可以认为不相关的信息，保留了图像重要的结构属性。有许多方法用于边缘检测，它们的绝大部分可以划分为两类：基于查找一类和基于零穿越的一类。基于查找的方法通过寻找图像一阶导数中的最大和最小值来检测边界，通常是将边界定位在梯度最大的方向。基于零穿越的方法通过寻找图像二阶导数零穿越来寻找边界，通常是Laplacian过零点或者非线性差分表示的过零点。

== 边缘属性 ==
边缘可能''与视角有关''——也就是说边缘可能随着视角不同而变化，典型地反映在场景、物体的几何形状一个将另一个遮挡起来，也可能''与视角无关''——这通常反映被观察物体的属性如表面纹理和表面形状。在二维乃至更高维空间中，需要考虑透视[[投影|投影]]的影响。

一个典型的边界可能是（例如）一块红色和一块黄色之间的边界；与此相反的是'''[[line_(mathematics)|边线]]'''可能是在另外一种不变的背景上的少数不同颜色的点。在边线的每一边都有一个边缘。在许多图像处理的应用中边缘都起着非常重要的作用。然而，在最近几年，不明显依赖于边缘检测作为预处理的计算机视觉处理方法研究取得了一些实质性（成功）的研究成果。

== 简单边缘模型 ==
自然界图像的边缘并不总是理想的阶梯边缘。相反，它们通常受到一个或多个下面所列因素的影响：
* 有限[[场景深度|场景深度]]带来的聚焦模糊.
* 非零半径光源产生的阴影带来的[[半影|半影模糊]].
* 光滑物体边缘的[[阴影|阴影]].
* 物体边缘附近的局部[[镜面反射|镜面反射]]或者[[漫反射|漫反射]].

尽管下面的模型不很完美，但是[[误差函数|误差函数]]<math>\operatorname{erf}</math>还是常被用于实际应用中边缘模糊效果的建模。

这样，一个在位置<math>0</math>之边界的一维图像<math>f</math>可以用下面的模型来表示：

<math>f(x) = \frac{I_r - I_l}{2} \left( \operatorname{erf}\left(\frac{x}{\sqrt{2}\sigma}\right) + 1\right) + I_l</math>

这样，在边界的左侧亮度是<math>I_l = \lim_{x \rightarrow -\infty} f(x)</math>，在右侧亮度是 
<math>I_r = \lim_{x \rightarrow \infty} f(x)</math>；<math>\sigma</math>被称为边缘模糊度。

注意<math>f</math>可以写为[[卷积|卷积]]<math>f = g_\sigma * u</math>，其中<math>g_\sigma</math>是[[标准偏差|标准偏差]]<math>\sigma</math>的[[高斯核|高斯核]]（[[:w:gaussian_kernel|gaussian kernel]]），<math>u</math>是下面定义的一个[[阶跃函数|阶跃函数]]：

<math>u(x) := \left\{
\begin{matrix}
  I_l, & \mathrm{if} \; x \leq 0\\
  I_r, & \mathrm{otherwise}
\end{matrix}
\right.</math>

== 检测边缘不是一个简单的问题 ==

如果将边缘认为是一定数量点亮度发生变化的地方，那么边缘检测大体上就是计算这个亮度变化的导数。为简化起见，我们可以先在一维空间分析边缘检测。在这个例子中，我们的数据是一行不同点亮度的数据。例如，在下面的1维数据中我们可以直观地说在第4与第5个点之间有一个边界：

<center>
{| border="1" cellpadding="3"
|-----
|  5  ||  7  ||  6 
|  4  ||  152  ||  148  ||  149 
|}</center>

除非场景中的物体非常简单并且照明条件得到了很好的控制，否则确定一个用来判断两个相邻点之间有多大的亮度变化才算是有边界的阈值，并不是一件容易的事。实际上，这也是为什么边缘检测不是一个简单问题的原因之一。

== 边缘检测的方法 ==
有许多用于边缘检测的方法，他们大致可分为两类：基于搜索和基于[[零交叉|零交叉]].

基于搜索的边缘检测方法首先计算边缘强度，通常用一阶导数表示，例如[[梯度|梯度]]模;然后，用计算估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值.

基于零交叉的方法找到由图像得到的二阶导数的零交叉点来定位边缘.通常用[[拉普拉斯算子|拉普拉斯算子]]或[[非线性微分方程|非线性微分方程]]的零交叉点，我们将在后面的小节中描述. 

[[图像降噪|滤波]]做为边缘检测的预处理通常是必要的，通常采用[[高斯滤波|高斯滤波]].

已发表的边缘检测方法应用计算边界强度的度量，这与平滑滤波有本质的不同.正如许多边缘检测方法依赖于图像梯度的计算，他们用不同种类的滤波器来估计x-方向和y-方向的梯度.

=== 计算一阶导数 ===
许多边缘检测操作都是基于亮度的一阶[[导数|导数]]——这样就得到了原始数据亮度的[[Image_gradient|梯度]]。使用这个信息我们能够在图像的亮度梯度中搜寻峰值。

如果''I''（''x''） 表示点''x''的亮度，''I''′（''x''） 表示点''x''的一阶导数（亮度梯度），这样我们就会发现：

: <math>I'(x)=-1/2\cdot I(x-1) + 0 \cdot I(x) + 1/2 \cdot I(x+1).\,</math>

对于更高性能的图像处理来说，一阶导数能够通过带有掩码的原始数据（1维）[[卷积|卷积]]计算得到。

<center>
{| border="1" cellpadding="3"
|-----
| −1/2 || 0 || 1/2
|}</center>

=== 计算二阶导数 ===
其它一些边缘检测操作是基于亮度的二阶导数。这实质上是亮度梯度的[[变化率|变化率]]。在理想的连续变化情况下，在二阶导数中检测过零点将得到梯度中的局部最大值。另一方面，二阶导数中的峰值检测是边线检测，只要图像操作使用一个合适的尺度表示。如上所述，边线是双重边缘，这样我们就可以在边线的一边看到一个亮度梯度，而在另一边看到相反的梯度。这样如果图像中有边线出现的话我们就能在亮度梯度上看到非常大的变化。为了找到这些边线，我们可以在图像亮度梯度的二阶导数中寻找过零点。

如果''I''（''x''） 表示点''x''的亮度，''I''′′（''x''） 表示点''x''亮度的二阶导数，那么：

:<math>I''(x) = 1\cdot I(x-1) - 2 \cdot I(x) + 1 \cdot I(x+1).\,</math>

同样，许多算法也使用[[卷积|卷积]]掩码快速处理图像数据：

<center>
{| border="1" cellpadding="3"
|-----
| +1 || −2 || +1
|}
</center>

=== 閾值確定 ===
一旦我們計算出導數之後，下一步要做的就是給出一個閾值來確定哪裡是邊緣位置。閾值越低，能夠檢測出的邊線越多，結果也就越容易受到[[image_noise|圖片雜訊]]的影響，並且越容易從圖像中挑出不相關的特性。與此相反，一個高的閾值將會遺失細的或者短的線段。

一個常用的這種方法是帶有[[hysteresis|滯後作用]]的[[閾值選擇|閾值選擇]]。這個方法使用不同的閾值去尋找邊緣。首先使用一個閾值上限去尋找邊線開始的地方。一旦找到了一個開始點，我們在圖像上逐點跟蹤邊緣路徑，當大於門檻下限時一直紀錄邊緣位置，直到數值小於下限之後才停止紀錄。這種方法假設邊緣是連續的界線，並且我們能夠跟蹤前面所看到的邊緣的模糊部分，而不會將圖像中的雜訊點標記為邊緣。

== 边缘检测算子 ==
* 一阶：[[Roberts_Cross算子|Roberts Cross算子]], [[Prewitt算子|Prewitt算子]], [[Sobel算子|Sobel算子]], [[Canny算子|Canny算子]]，[[罗盘算子|罗盘算子]]
* 二阶：[[Marr-Hildreth_algorithm|Marr-Hildreth]],在梯度方向的二阶导数[[zero-crossing|过零点]]。

目前，[[Canny算子|Canny算子]]（或者这个算子的变体）是最常用的边缘检测方法。
在Canny创造性的工作中，他研究了设计一个用于边缘检测最优预[[smoothing|平滑]]滤波器中的问题，后来他说明这个滤波器能够很好地被一阶[[高斯函数|高斯导数核]]优化。另外Canny引入了非最大抑制概念，它是说边缘定义为在梯度方向具有最大梯度值的点。

在一个离散矩阵中，非最大抑制阶梯能够通过一种方法来实现，首先预测一阶导数方向、然后把它近似到45度的倍数、最后在预测的梯度方向比较梯度幅度。

一个获得亚点精度边缘的改进实现是通过检测梯度方向上二阶方向梯度的过零点来实现的：
<math>L_x^2 \, L_{xx} + 2 \, L_x \,  L_y \, L_{xy} + L_y^2 \, L_{yy} = 0,</math>
它在梯度方向的三阶方向梯度满足符号条件
: <math>L_x^3 \, L_{xxx} + 3 \, L_x^2 \, L_y \, L_{xxy} + 3 \, L_x \, L_y^2 \, L_{xyy} + L_y^3 \, L_{yyy} < 0</math>
其中，<math>L_x</math>, <math>L_y</math> ... <math>L_{yyy}</math>表示从使用高斯核平滑原始图像得到的[[尺度空间|尺度空间]]表示<math>L</math>计算出的偏微分。

按照这种方法，能够自动得到亚点精度的连续曲线边缘。

滞后门槛也可以用在这些差分边缘片断。

[[罗盘算子|罗盘算子]]是斯坦福大学的Ruzon在1999年提出的一个新的算子，据实验以及报道，性能超过Canny算子。

== 参考文献 ==
=== 引用 ===
{{Reflist}}

=== 来源 ===
; 期刊文章
* {{cite journal |last = Canny |first = J. |title = "A Computational Approach To Edge Detection"（《一种边缘检测的计算方法》） |journal = ''IEEE Trans. Pattern Analysis and Machine Intelligence'' |issue = 8 |pages = 679-714 |year = 1986}}
* {{cite journal |last = Lindeberg |first = Tony |title = "Edge detection and ridge detection with automatic scale selection"（《自动尺度选择的边缘及山脊线检测》） |journal = ''International Journal of Computer Vision'' |volume = 30 |issue = 2 |pages = 117-154 |year = 1998 |url = http://www.nada.kth.se/cvap/abstracts/cvap191.html}} (Includes the differential approach to non-maximum suppression.)

== 参见 ==
{{Portal box|计算机科学}}
* [[霍夫变换|霍夫变换]]（Hough Transform），用来做直线检测.
* [[原子线滤波器|原子线滤波器]]（atomic line filter），用来做直线检测.

[[Category:特征检测_(计算机视觉)|Category:特征检测 (计算机视觉)]]